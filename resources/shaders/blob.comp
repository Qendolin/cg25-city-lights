#version 460

#include "blob_lookup.glsl"

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(push_constant) uniform PushConsts {
    vec3 aabbMin;
    float cellSize;
    vec3 aabbMax;
    float time;
    vec3 globalGridOrigin;
    uint metaballIndexOffset;
    uint metaballCount;
    float groundLevel;
    uint drawIndex;
    uint firstVertex;
} cParams;

struct Metaball {
    vec4 position;
    vec4 scale;
    float radius;
    float maxRadius;
    float _pad0;
    float _pad1;
};

struct Vertex {
    vec4 position;
    vec4 normal;
    vec4 tangent;
};

struct DrawCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

layout(set = 0, binding = 0, std430) readonly buffer MetaballBuffer {
    Metaball metaballs[];
};

layout(set = 0, binding = 1, std430) writeonly restrict buffer VertexBuffer {
    Vertex vertices[];
};

// Atomic add makes this r+w
layout(set = 0, binding = 2, std430) buffer DrawCommandBuffer {
    DrawCommand drawCommands[];
};

layout(set = 0, binding = 3, std430) readonly buffer MetaballIndexBuffer {
    uint metaballIndices[];
};

// Constants
const float ISO_VALUE = 0.0;
const float EPS = 1e-4;

// Shared memory
shared uint groupVertexCount;
shared uint groupGlobalBaseIndex;

struct MarchingCell {
    vec3 vertices[8];
    float samples[8];
    int lookupIndex;
};

struct IntersectionPoint {
    vec3 position;
    vec3 normal;
};

// SDF Functions

float ellipsoidSdf(vec3 p, Metaball b) {
    vec3 localP = (p - b.position.xyz) / b.scale.xyz;
    float dLocal = length(localP);
    float minScale = min(b.scale.x, min(b.scale.y, b.scale.z));

    // (Local Distance - Local Radius) * World Scale Factor
    return (dLocal - b.radius) * minScale;
}

float smoothMin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

float evaluateField(vec3 p) {
    // 1. Accumulate Metaballs
    // Initialize with a safe "far away" value
    uint firstIdx = metaballIndices[cParams.metaballIndexOffset];
    Metaball b1 = metaballs[firstIdx];
    float result = ellipsoidSdf(p, b1);

    // 2. Accumulate Remaining
    for (uint i = 1; i < cParams.metaballCount; ++i) {
        uint idx = metaballIndices[cParams.metaballIndexOffset + i];
        Metaball b = metaballs[idx];

        // Compute SDF
        float dist = ellipsoidSdf(p, b);

        // Compute Smoothing Factor
        float minS = min(b.scale.x, min(b.scale.y, b.scale.z));
        float k = (b.maxRadius - b.radius) * minS;

        // Blend
        result = smoothMin(result, dist, k);
    }

    // 2. Ground Logic
//    float h = p.y - cParams.groundLevel;
//    float suction = 0.5 * exp(-h * 3.0);
//    result -= suction;
//    result = max(result, -h);

    return result;
}

// Snap point to global grid
vec3 snapToGlobalGrid(vec3 point) {
    vec3 offset = point - cParams.globalGridOrigin;
    vec3 snapped = round(offset / cParams.cellSize) * cParams.cellSize;
    return cParams.globalGridOrigin + snapped;
}

// Get global grid-aligned cell vertices
MarchingCell initCell(vec3 cellOrigin) {
    MarchingCell cell;

    float s = cParams.cellSize;
    const vec3 offsets[8] = {
    vec3(0, 0, 0), vec3(s, 0, 0), vec3(0, s, 0), vec3(s, s, 0),
    vec3(0, 0, s), vec3(s, 0, s), vec3(0, s, s), vec3(s, s, s)
    };

    cell.lookupIndex = 0;
    for (int i = 0; i < 8; ++i) {
        cell.vertices[i] = cellOrigin + offsets[i];
        cell.samples[i] = evaluateField(cell.vertices[i]);
        if (cell.samples[i] < ISO_VALUE) {
            cell.lookupIndex |= (1 << i);
        }
    }

    return cell;
}

// Edge interpolation
vec3 interpolateEdge(vec3 v0, vec3 v1, float s0, float s1) {
    float t = (ISO_VALUE - s0) / (s1 - s0 + 1e-8);
    return mix(v0, v1, t);
}

// Normal calculation via gradient
vec3 calculateNormal(vec3 p) {
    float d = evaluateField(p);
    vec3 grad = vec3(
    evaluateField(p + vec3(EPS, 0.0, 0.0)) - d,
    evaluateField(p + vec3(0.0, EPS, 0.0)) - d,
    evaluateField(p + vec3(0.0, 0.0, EPS)) - d
    );
    return normalize(grad);
}

// Calculate intersection point on edge
IntersectionPoint calculateIntersection(MarchingCell cell, int edgeIdx) {
    int v0 = edgeVertexIndices[edgeIdx][0];
    int v1 = edgeVertexIndices[edgeIdx][1];

    vec3 pos = interpolateEdge(
    cell.vertices[v0],
    cell.vertices[v1],
    cell.samples[v0],
    cell.samples[v1]
    );

    IntersectionPoint ip;
    ip.position = pos;
    ip.normal = calculateNormal(pos);
    return ip;
}

// Tangent from normal
vec4 calculateTangent(vec3 normal) {
    vec3 helper = abs(normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    vec3 tangent = normalize(cross(normal, helper));
    tangent = normalize(tangent - normal * dot(normal, tangent));
    return vec4(tangent, 1.0);
}

// Emit all triangles for this cell
uint emitTriangles(MarchingCell cell, uint baseVertexIndex) {
    IntersectionPoint intersections[12];

    // Pre-calculate active edge intersections
    int edgeKey = edgeTable[cell.lookupIndex];
    for (int i = 0; i < 12; ++i) {
        if ((edgeKey & (1 << i)) != 0) {
            intersections[i] = calculateIntersection(cell, i);
        }
    }

    // Emit triangles
    uint vertIdx = baseVertexIndex;
    for (int t = 0; t < 12 && triangleTable[cell.lookupIndex][t] != -1; t += 3) {
        for (int v = 0; v < 3; ++v) {
            int edgeIdx = triangleTable[cell.lookupIndex][t + v];
            IntersectionPoint ip = intersections[edgeIdx];

            vertices[vertIdx++] = Vertex(
            vec4(ip.position, 1.0),
            vec4(ip.normal, 0.0),
            calculateTangent(ip.normal)
            );
        }
    }

    return vertIdx - baseVertexIndex;
}

void main() {
    // 1. Setup Coordinates
    ivec3 localCellCoord = ivec3(gl_GlobalInvocationID);
    vec3 aabbSize = cParams.aabbMax - cParams.aabbMin;
    ivec3 cellCount = ivec3(ceil(aabbSize / cParams.cellSize));

    // 2. Logic Flag - instead of returning, we set this to false.
    bool isActive = true;

    // Bounds Check
    if (any(greaterThanEqual(localCellCoord, cellCount))) {
        isActive = false;
    }

    // 3. Grid Position Calculation
    vec3 cellOrigin = cParams.aabbMin + vec3(localCellCoord) * cParams.cellSize;
    vec3 offset = cellOrigin - cParams.globalGridOrigin;
    cellOrigin = cParams.globalGridOrigin + round(offset / cParams.cellSize) * cParams.cellSize;
    vec3 cellCenter = cellOrigin + vec3(cParams.cellSize * 0.5);

    // 4. Ownership & SDF Check (Only run heavy math if still active)
    // We use a safe default value so inactive threads don't produce garbage
    float centerVal = 1e10;

//    if (isActive) {
//        vec3 center = cellOrigin + vec3(cParams.cellSize * 0.5);
//        // If center is far from surface (approx sqrt(3)/2 * size), corners won't cross iso-surface
//        if (evaluateField(center) > cParams.cellSize * 0.87) {
//            isActive = false;
//        }
//    }

    // 5. Marching Cubes (Only if active)
    MarchingCell cell;
    uint numVerts = 0;

    if (isActive) {
        cell = initCell(cellOrigin);
        for (int t = 0; t < 12 && triangleTable[cell.lookupIndex][t] != -1; t += 3) {
            numVerts += 3;
        }
    }

    // 6. Synchronization

    // Barrier 1: Reset local group count
    if (gl_LocalInvocationIndex == 0) {
        groupVertexCount = 0;
    }
    barrier();

    // Barrier 2: Local Atomic Add
    // Only active threads with geometry contribute, but ALL threads hit the barrier.
    uint localOffset = 0;
    if (isActive && numVerts > 0) {
        localOffset = atomicAdd(groupVertexCount, numVerts);
    }
    barrier();

    // Barrier 3: Global Atomic Add
    // Only one thread per group does the global write, but ALL threads wait.
    if (gl_LocalInvocationIndex == 0) {
        if (groupVertexCount > 0) {
            groupGlobalBaseIndex = atomicAdd(drawCommands[cParams.drawIndex].vertexCount, groupVertexCount);
        } else {
            groupGlobalBaseIndex = 0; // dummy write for defined behavior
        }
    }
    barrier();

    // 7. Output Geometry
    if (isActive && numVerts > 0) {
        uint baseIndex = groupGlobalBaseIndex + localOffset + cParams.firstVertex;
        emitTriangles(cell, baseIndex);
    }
}