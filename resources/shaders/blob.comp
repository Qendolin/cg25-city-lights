#version 460

#include "blob_lookup.glsl"

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(push_constant) uniform PushConsts {
    int resolution;
    float time;
    float groundLevel;
    float size;
} pc;

struct Vertex {
    vec4 position;
    vec4 normal;
    vec4 tangent;
};

layout(set = 0, binding = 0, std430) buffer Vertices {
    Vertex vertices[];
};

layout(set = 0, binding = 1, std430) buffer DrawArgs {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} drawArgs;

// Constants
const float INTERVAL_START = -1.0;
const float INTERVAL_END = 1.0;
const float ISO_VALUE = 0.0;
const float EPS = 1e-4;
const float TWO_PI = 6.28318530718;
const float PI = 3.14159265359;
const float SDF_CENTER_Y = 0.3;
const float SDF_PULSE_AMP = 0.2;

// Shared memory for workgroup coordination
shared uint groupVertexCount;
shared uint groupGlobalBaseIndex;

// Cell data structure
struct MarchingCell {
    vec3 vertices[8];
    float samples[8];
    int lookupIndex;
};

struct IntersectionPoint {
    vec3 position;
    vec3 normal;
};

// SDF evaluation
float sphereSdf(vec3 point, vec3 center, float size) {
    return length(point - center) - size;
}

float smoothMin(float a, float b, float smoothing) {
    float h = clamp(0.5 + 0.5 * (b - a) / smoothing, 0.0, 1.0);
    return mix(b, a, h) - smoothing * h * (1.0 - h);
}

float sdf(vec3 point) {
    float groundCutoff = point.y - pc.groundLevel + 0.05;
    point = point / pc.size;
    float timeLooped = mod(pc.time, PI);

    // Core sphere
    vec3 centerCore = vec3(0.0, SDF_CENTER_Y, 0.0);
    float sizeCore = 0.2 + SDF_PULSE_AMP * sin(timeLooped * 2.0);
    float core = sphereSdf(point, centerCore, sizeCore);

    float time2 = timeLooped * 2.0;
    float time4 = timeLooped * 4.0;

    // Orbiting spheres
    float radius1 = 0.25;
    vec3 center1 = vec3(radius1 * cos(time2), SDF_CENTER_Y, radius1 * sin(time2));
    float s1 = sphereSdf(point, center1, 0.2);

    float radius2 = 0.25;
    vec3 center2 = vec3(radius2 * cos(time2), radius2 * sin(time2) + SDF_CENTER_Y - 0.05, 0.0);
    float s2 = sphereSdf(point, center2, 0.2);

    float radius3 = 0.30;
    vec3 center3 = vec3(0.0, radius3 * cos(-time4) + SDF_CENTER_Y - 0.05, radius3 * sin(-time4));
    float s3 = sphereSdf(point, center3, 0.2);

    // Combine with smooth min
    float val = smoothMin(core, s1, 0.4);
    val = smoothMin(val, s2, 0.4);
    val = smoothMin(val, s3, 0.4);

    return smoothMin(val, groundCutoff, 0.4);
}

// Cell initialization
MarchingCell initCell(ivec3 cellCoord, float stepSize) {
    MarchingCell cell;

    vec3 origin = vec3(INTERVAL_START) + vec3(cellCoord) * stepSize;

    // Initialize vertices (cube corners)
    cell.vertices[0] = origin;
    cell.vertices[1] = origin + vec3(stepSize, 0.0, 0.0);
    cell.vertices[2] = origin + vec3(0.0, stepSize, 0.0);
    cell.vertices[3] = origin + vec3(stepSize, stepSize, 0.0);
    cell.vertices[4] = origin + vec3(0.0, 0.0, stepSize);
    cell.vertices[5] = origin + vec3(stepSize, 0.0, stepSize);
    cell.vertices[6] = origin + vec3(0.0, stepSize, stepSize);
    cell.vertices[7] = origin + vec3(stepSize, stepSize, stepSize);

    // Sample SDF at vertices
    for (int i = 0; i < 8; ++i) {
        cell.samples[i] = sdf(cell.vertices[i]);
    }

    // Calculate lookup index
    cell.lookupIndex = 0;
    for (int i = 0; i < 8; ++i) {
        if (cell.samples[i] < ISO_VALUE) {
            cell.lookupIndex |= (1 << i);
        }
    }

    return cell;
}

// Intersection calculation
vec3 interpolateEdge(vec3 v0, vec3 v1, float s0, float s1) {
    float t = (ISO_VALUE - s0) / (s1 - s0 + 1e-8);
    return mix(v0, v1, t);
}

vec3 calculateNormal(vec3 p) {
    float d = sdf(p);
    vec3 grad = vec3(
    sdf(p + vec3(EPS, 0.0, 0.0)) - d,
    sdf(p + vec3(0.0, EPS, 0.0)) - d,
    sdf(p + vec3(0.0, 0.0, EPS)) - d
    );
    return normalize(grad);
}

IntersectionPoint calculateIntersection(MarchingCell cell, int edgeIdx) {
    int v0 = edgeVertexIndices[edgeIdx][0];
    int v1 = edgeVertexIndices[edgeIdx][1];

    vec3 pos = interpolateEdge(
    cell.vertices[v0],
    cell.vertices[v1],
    cell.samples[v0],
    cell.samples[v1]
    );

    IntersectionPoint ip;
    ip.position = pos;
    ip.normal = calculateNormal(pos);
    return ip;
}

// Tangent calculation
vec4 calculateTangent(vec3 normal) {
    vec3 helper = abs(normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    vec3 tangent = normalize(cross(normal, helper));

    // Orthogonalize
    tangent = normalize(tangent - normal * dot(normal, tangent));

    return vec4(tangent, 1.0);
}

// Triangle emission
uint emitTriangles(MarchingCell cell, uint baseVertexIndex) {
    IntersectionPoint intersections[12];

    // Pre-calculate intersections for active edges
    int edgeKey = edgeTable[cell.lookupIndex];
    for (int i = 0; i < 12; ++i) {
        if ((edgeKey & (1 << i)) != 0) {
            intersections[i] = calculateIntersection(cell, i);
        }
    }

    // Emit triangles
    uint vertIdx = baseVertexIndex;
    for (int t = 0; t < 12 && triangleTable[cell.lookupIndex][t] != -1; t += 3) {
        for (int v = 0; v < 3; ++v) {
            int edgeIdx = triangleTable[cell.lookupIndex][t + v];
            IntersectionPoint ip = intersections[edgeIdx];

            vertices[vertIdx++] = Vertex(
            vec4(ip.position, 1.0),
            vec4(ip.normal, 0.0),
            calculateTangent(ip.normal)
            );
        }
    }

    return vertIdx - baseVertexIndex;
}

void main() {
    ivec3 cellCoord = ivec3(gl_GlobalInvocationID);

    // Calculate step size
    float stepSize = (INTERVAL_END - INTERVAL_START) / float(pc.resolution);

    // Initialize cell data
    MarchingCell cell = initCell(cellCoord, stepSize);

    // Count vertices needed
    uint numVerts = 0;
    for (int t = 0; t < 12 && triangleTable[cell.lookupIndex][t] != -1; t += 3) {
        numVerts += 3;
    }

    // Workgroup allocation - MUST participate in all barriers
    if (gl_LocalInvocationIndex == 0) {
        groupVertexCount = 0;
    }
    barrier();

    uint localOffset = atomicAdd(groupVertexCount, numVerts);

    barrier();

    if (gl_LocalInvocationIndex == 0) {
        groupGlobalBaseIndex = atomicAdd(drawArgs.vertexCount, groupVertexCount);
    }
    barrier();

    if (numVerts > 0) {
        uint baseIndex = groupGlobalBaseIndex + localOffset;
        emitTriangles(cell, baseIndex);
    }
}