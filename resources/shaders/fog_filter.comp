#version 460
#include "common/math.glsl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (set = 0, binding = 0) uniform sampler2DMS in_depth;
layout (set = 0, binding = 1) uniform sampler2D in_source;
layout (set = 0, binding = 2, rgba16f) uniform restrict image2D out_color;

layout (push_constant) uniform ShaderParamPush {
    float zNear;
    float sharpness;
} cParams;

float getLinearZ(ivec2 p) {
    float d = texelFetch(in_depth, p, 0).x;
    return cParams.zNear / max(d, 1e-6);
}

float detectEdge(ivec2 p) {
    float c = getLinearZ(p);

    float z0 = getLinearZ(p + ivec2(-1, -1));
    float z1 = getLinearZ(p + ivec2( 0, -1));
    float z2 = getLinearZ(p + ivec2( 1, -1));
    float z3 = getLinearZ(p + ivec2(-1,  0));
    float z4 = getLinearZ(p + ivec2( 1,  0));
    float z5 = getLinearZ(p + ivec2(-1,  1));
    float z6 = getLinearZ(p + ivec2( 0,  1));
    float z7 = getLinearZ(p + ivec2( 1,  1));

    float max_diff = max(max(max(abs(z0 - c), abs(z1 - c)), max(abs(z2 - c), abs(z3 - c))),
    max(max(abs(z4 - c), abs(z5 - c)), max(abs(z6 - c), abs(z7 - c))));

    return saturate(max_diff * cParams.sharpness * 0.5);
}

void main()
{
    ivec2 out_size = imageSize(out_color);
    ivec2 half_size = textureSize(in_source, 0);
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);

    if (p.x >= out_size.x || p.y >= out_size.y)
    return;

    vec2 uv = (vec2(p) + 0.5) / vec2(out_size);
    float center_z = getLinearZ(p);

    float edge_strength = detectEdge(p);

    vec3 result_radiance;
    float result_tau;

    if (edge_strength > 0.5) {
        // Edge region: Depth-weighted bilinear
        vec2 half_uv = (vec2(p) + 0.5) / vec2(out_size) * vec2(half_size);
        ivec2 base = ivec2(floor(half_uv - 0.5));
        vec2 frac = fract(half_uv - 0.5);

        vec3 accum_radiance = vec3(0.0);
        float accum_tau = 0.0;
        float accum_weight = 0.0;

        // Sample 2x2 quad with bilinear + depth weights
        for (int j = 0; j <= 1; ++j) {
            for (int i = 0; i <= 1; ++i) {
                ivec2 sample_coord = base + ivec2(i, j);
                sample_coord = clamp(sample_coord, ivec2(0), half_size - 1);
                vec2 sample_uv = (vec2(sample_coord) + 0.5) / vec2(half_size);

                vec4 fog_sample = textureLod(in_source, sample_uv, 0.0);

                // Get depth at the center of this half-res cell
                ivec2 full_res_center = ivec2((sample_uv * vec2(out_size)));
                full_res_center = clamp(full_res_center, ivec2(0), out_size - 1);
                float sample_z = getLinearZ(full_res_center);

                // Bilinear weight
                vec2 offset = vec2(i, j);
                float bilinear_w = mix(mix(
                (1.0 - frac.x) * (1.0 - frac.y),
                frac.x * (1.0 - frac.y),
                float(i)
                ), mix(
                (1.0 - frac.x) * frac.y,
                frac.x * frac.y,
                float(i)
                ), float(j));

                // Depth weight - exponential falloff
                float depth_diff = abs(sample_z - center_z) / max(center_z, 0.1);
                float depth_w = exp(-depth_diff * cParams.sharpness * 15.0);

                float w = bilinear_w * depth_w;

                accum_radiance += fog_sample.rgb * w;
                accum_tau += fog_sample.a * w;
                accum_weight += w;
            }
        }

        if (accum_weight > 1e-5) {
            result_radiance = accum_radiance / accum_weight;
            result_tau = accum_tau / accum_weight;
        } else {
            // No good depth matches - fallback to pure bilinear
            vec4 fallback = textureLod(in_source, uv, 0.0);
            result_radiance = fallback.rgb;
            result_tau = fallback.a;
        }

    } else {
        // Smooth region: Standard bilateral with adaptive kernel
        int kernel_radius = edge_strength > 0.2 ? 1 : 2;

        vec3 accum_radiance = vec3(0.0);
        float accum_tau = 0.0;
        float accum_weight = 0.0;

        float z_right = getLinearZ(min(p + ivec2(1, 0), out_size - 1));
        float z_left = getLinearZ(max(p - ivec2(1, 0), ivec2(0)));
        float z_up = getLinearZ(min(p + ivec2(0, 1), out_size - 1));
        float z_down = getLinearZ(max(p - ivec2(0, 1), ivec2(0)));

        float dzdx = 0.5 * (z_right - z_left);
        float dzdy = 0.5 * (z_up - z_down);

        vec2 half_texel = 1.0 / vec2(half_size);

        for (int j = -kernel_radius; j <= kernel_radius; ++j) {
            for (int i = -kernel_radius; i <= kernel_radius; ++i) {
                vec2 offset = vec2(i, j);
                vec2 sample_uv = uv + offset * half_texel;

                if (sample_uv.x < 0.0 || sample_uv.x > 1.0 ||
                sample_uv.y < 0.0 || sample_uv.y > 1.0)
                continue;

                vec4 src = textureLod(in_source, sample_uv, 0.0);

                vec2 full_res_pos = sample_uv * vec2(out_size);
                ivec2 sample_p = ivec2(full_res_pos);
                sample_p = clamp(sample_p, ivec2(0), out_size - 1);
                float sample_z = getLinearZ(sample_p);

                float spatial_dist = length(offset);
                float spatial_w = exp(-spatial_dist * spatial_dist * 0.5);

                vec2 pixel_offset = offset * vec2(half_size) / vec2(out_size) * 2.0;
                float expected_z = center_z + dot(pixel_offset, vec2(dzdx, dzdy));
                float depth_error = abs(sample_z - expected_z) / max(center_z, 0.1);
                float depth_w = exp(-depth_error * cParams.sharpness * 10.0);

                float w = spatial_w * depth_w;

                accum_radiance += src.rgb * w;
                accum_tau += src.a * w;
                accum_weight += w;
            }
        }

        if (accum_weight > 1e-5) {
            result_radiance = accum_radiance / accum_weight;
            result_tau = accum_tau / accum_weight;
        } else {
            result_radiance = textureLod(in_source, uv, 0.0).rgb;
            result_tau = textureLod(in_source, uv, 0.0).a;
        }
    }

    float result_transmittance = exp(-result_tau);
    vec4 scene = imageLoad(out_color, p);

    imageStore(out_color, p, vec4(scene.rgb * result_transmittance + result_radiance, scene.a));
}