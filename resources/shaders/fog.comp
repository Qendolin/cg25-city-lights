#version 460 core

#extension GL_KHR_shader_subgroup_shuffle : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define SHADOW_CASCADE_COUNT 5

layout(set = 0, binding = 0) uniform sampler2DMS in_depth;
layout(set = 0, binding = 1, rgba16f) uniform restrict image2D inout_hdr;
layout(set = 0, binding = 2) uniform sampler2DShadow uShadowMaps[SHADOW_CASCADE_COUNT];

struct ShadowCascade {
    mat4 transform;
    vec2 boundsMin;
    vec2 boundsMax;
};

layout (std140, set = 0, binding = 3) uniform ShadowCascadesUniforms {
    ShadowCascade[SHADOW_CASCADE_COUNT] uShadowCascades;
};

layout (push_constant) uniform ShaderParamConstants
{
    vec2 inverseProjectionScale;
    vec2 inverseProjectionOffset;
    vec3 sunUpVS;
    float zNear;
    vec3 sunRightVS;
    float density;
    vec3 sunRadiance;
    float targetStepContribution;
    vec3 ambientRadiance;
    float cameraHeight;
    vec3 worldUpVS;
    float heightFalloff;
    vec3 fogColor;
    uint samples;
    vec3 sunDirVS;
    float g;
    int depthSampleIndex;
    uint frame;
    float pad1;
    float pad2;
} cParams;

vec3 unprojectRay(vec2 p) {
    vec2 ray_xy = fma(p, cParams.inverseProjectionScale, cParams.inverseProjectionOffset);
    return normalize(vec3(ray_xy.x, -ray_xy.y, -1.0f));
}

float depthToViewZ(float d) {
    return cParams.zNear / d;
}

// Improved blue noise-like dithering using interleaved gradient noise
float interleavedGradientNoise(vec2 screen_pos, uint frame_count) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    float noise = fract(magic.z * fract(dot(screen_pos, magic.xy)));
    // Temporal variation
    return fract(noise + float(frame_count % 64) * 0.61803398875);
}

// R2 sequence for low-discrepancy sampling
vec2 r2Sequence(uint n) {
    const float g = 1.32471795724474602596;
    const float a1 = 1.0 / g;
    const float a2 = 1.0 / (g * g);
    return fract(vec2(a1, a2) * float(n));
}

const float PI = 3.14159265359;
const float MIN_STEP_SIZE = 0.05;
const float MAX_STEP_SIZE = 25.0;
const float EPSILON_DENSITY = 1e-5;

float henyeyGreenstein(float g, float cos_theta) {
    float g2 = g * g;
    float num = 1.0 - g2;
    float denom = 4.0 * PI * pow(1.0 + g2 - 2.0 * g * cos_theta, 1.5);
    return num / max(denom, 0.0001);
}

// Improved step size calculation based on constant inscattering contribution
// This ensures perceptually uniform contribution from each sample
float computeAdaptiveStep(float extinction, float current_transmittance) {
    if (extinction < EPSILON_DENSITY || current_transmittance < 0.001) {
        return MAX_STEP_SIZE;
    }

    // We want each step to contribute the same amount to the final radiance
    // Contribution = transmittance * inscattered_light * (1 - exp(-extinction * step))
    // For constant contribution: transmittance * (1 - exp(-extinction * step)) = constant
    // Solving for step: step = -ln(1 - constant/transmittance) / extinction
    // where constant = targetStepContribution (target contribution per step)

    float target_contribution = cParams.targetStepContribution;

    // Clamp the argument to ln to avoid negative or zero values
    float ln_arg = 1.0 - target_contribution / current_transmittance;
    ln_arg = max(ln_arg, 0.001); // Prevent log(0) or log(negative)

    float step = -log(ln_arg) / extinction;

    return clamp(step, MIN_STEP_SIZE, MAX_STEP_SIZE);
}

void main() {
    if (any(greaterThanEqual(gl_GlobalInvocationID.xy, imageSize(inout_hdr)))) {
        return;
    }
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    float depth = texelFetch(in_depth, coord, cParams.depthSampleIndex).r;
    float view_z = depthToViewZ(depth);

    vec3 ray = unprojectRay(vec2(coord) + 0.5);

    // Improved jittering: spatial + temporal variation
    float initial_jitter = interleavedGradientNoise(vec2(coord), cParams.frame);

    float t = 0.0;
    vec3 radiance = vec3(0.0);
    float transmittance = 1.0;

    float cos_theta = dot(ray, cParams.sunDirVS);
    float phase = henyeyGreenstein(cParams.g, cos_theta);

    int cascade_index = 0;

    for (uint i = 0; i < cParams.samples; ++i) {
        // Per-sample jitter using R2 sequence combined with initial jitter
        // This breaks up the regular pattern while maintaining good distribution
        vec2 r2 = r2Sequence(i + cParams.frame * cParams.samples);
        float sample_jitter = fract(initial_jitter + r2.x);

        // Sample position with jitter applied to THIS step
        vec3 p = ray * t;

        // Density at current position
        float height = cParams.cameraHeight + dot(p, cParams.worldUpVS);
        float height_factor = exp(-cParams.heightFalloff * max(height, 0.0));
        float extinction = cParams.density * height_factor;

        // Calculate adaptive step size based on current conditions
        float step_size = computeAdaptiveStep(extinction, transmittance);

        // Clamp to remaining distance
        step_size = min(step_size, view_z - t);

        // Apply jitter to step size (reduces banding further)
        float jittered_step = step_size * (0.5 + 0.5 * sample_jitter);

        // Advance ray with jittered step
        t += jittered_step;

        if (t >= view_z || transmittance < 0.01) {
            break;
        }

        // Recalculate position at actual sample point
        p = ray * t;
        height = cParams.cameraHeight + dot(p, cParams.worldUpVS);
        height_factor = exp(-cParams.heightFalloff * max(height, 0.0));
        extinction = cParams.density * height_factor;

        {
            // Project into light space
            float lx = dot(p, cParams.sunRightVS.xyz);
            float ly = dot(p, cParams.sunUpVS.xyz);

            // cascade index is always increasing
            for (int j = cascade_index; j < SHADOW_CASCADE_COUNT; ++j) {
                if (lx >= uShadowCascades[j].boundsMin.x && ly >= uShadowCascades[j].boundsMin.y
                && lx <= uShadowCascades[j].boundsMax.x && ly <= uShadowCascades[j].boundsMax.y) {
                    cascade_index = j;
                    break;
                }
            }
        }

        ShadowCascade cascade = uShadowCascades[cascade_index];
        vec4 p_shadow_ndc = cascade.transform * vec4(p, 1.0);

        vec3 shadow_uvz = vec3(p_shadow_ndc.xy * 0.5 + 0.5, p_shadow_ndc.z);
        float shadow = texture(uShadowMaps[cascade_index], shadow_uvz);

        // Integration with actual traveled distance
        float step_extinction = extinction * jittered_step;
        float step_transmittance = exp(-step_extinction);
        transmittance *= step_transmittance;

        vec3 in_radiance = cParams.sunRadiance * shadow * phase + cParams.ambientRadiance;
        float one_minus_t = 1.0 - step_transmittance;
        vec3 inscatter = transmittance * in_radiance * one_minus_t;
        radiance += inscatter;
    }

    // Subgroup sharing for spatial smoothing (optional - uncomment if desired)
    /*
    vec3 rad_h    = subgroupShuffleXor(radiance, 1);
    float trans_h = subgroupShuffleXor(transmittance, 1);
    vec3 rad_v    = subgroupShuffleXor(radiance, 8);
    float trans_v = subgroupShuffleXor(transmittance, 8);
    vec3 rad_d    = subgroupShuffleXor(radiance, 9);
    float trans_d = subgroupShuffleXor(transmittance, 9);

    radiance = (radiance + rad_h + rad_v + rad_d) * 0.25;
    transmittance = (transmittance + trans_h + trans_v + trans_d) * 0.25;
    */

    vec4 in_color = imageLoad(inout_hdr, coord);
    vec3 result = in_color.rgb * transmittance + radiance * cParams.fogColor;

    imageStore(inout_hdr, coord, vec4(result, in_color.a));
}