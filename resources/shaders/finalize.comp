#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D in_color;
layout(set = 0, binding = 1) uniform writeonly restrict image2D out_color;
layout(set = 0, binding = 2) uniform sampler2D in_fog;

struct AgXParams {
    float ev_min;
    float ev_max;
    float mid_gray;
    float offset;
    float slope;
    float power;
    float saturation;
};

layout (push_constant) uniform ShaderParamConstants
{
    AgXParams agx;
    vec4 fogColor;
} cParams;


vec3 agxDefaultContrastApprox(vec3 x) {
    vec3 x2 = x * x;
    vec3 x4 = x2 * x2;

    return + 15.5     * x4 * x2
           - 40.14    * x4 * x
           + 31.96    * x4
           - 6.868    * x2 * x
           + 0.4298   * x2
           + 0.1191   * x
           - 0.00232;
}

vec3 agx(vec3 val) {
    const mat3 agx_mat = mat3(
        0.842479062253094, 0.0423282422610123, 0.0423756549057051,
        0.0784335999999992,  0.878468636469772,  0.0784336,
        0.0792237451477643, 0.0791661274605434, 0.879142973793104);

    const float min_ev = cParams.agx.ev_min;
    const float max_ev = cParams.agx.ev_max;
    const float mid_gray = cParams.agx.mid_gray;

    // Input transform
    val = agx_mat * val;

    // Log2 space encoding
    val = clamp(log2(val / mid_gray), min_ev, max_ev);
    val = (val - min_ev) / (max_ev - min_ev);

    // Apply sigmoid function approximation
    val = agxDefaultContrastApprox(val);

    return val;
}

vec3 agxEotf(vec3 val) {
    const mat3 agx_mat_inv = mat3(
        1.19687900512017, -0.0528968517574562, -0.0529716355144438,
        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,
        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);

    // Undo input transform
    val = agx_mat_inv * val;

    return val;
}

vec3 agxLook(vec3 val) {
    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(val, lw);

    vec3 offset = vec3(cParams.agx.offset);
    vec3 slope = vec3(cParams.agx.slope);
    vec3 power = vec3(cParams.agx.power);
    float sat = cParams.agx.saturation;

    // ASC CDL
    val = pow(val * slope + offset, power);
    return luma + sat * (val - luma);
}


// Reference: https://www.shadertoy.com/view/cd3XWr
vec3 tonemapAgX(vec3 col) {
    col = agx(col);
    col = agxLook(col);
    col = agxEotf(col);
    return col;
}

vec2 getFogFiltered(ivec2 coord) {
    vec2 tex_size = vec2(textureSize(in_fog, 0));
    vec2 texel_size = 1.0 / tex_size;
    vec2 uv = (vec2(coord) + 0.5) * texel_size;

    vec2 d = texel_size * 0.5;

    vec2 s1 = texture(in_fog, uv + vec2(-d.x, -d.y)).rg;
    vec2 s2 = texture(in_fog, uv + vec2( d.x, -d.y)).rg;
    vec2 s3 = texture(in_fog, uv + vec2(-d.x,  d.y)).rg;
    vec2 s4 = texture(in_fog, uv + vec2( d.x,  d.y)).rg;

    return (s1 + s2 + s3 + s4) * 0.25;
}

void main() {
    if (any(greaterThanEqual(gl_GlobalInvocationID.xy, textureSize(in_color, 0)))) {
        return;
    }
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec3 color = texelFetch(in_color, coord, 0).rgb;

    // Fog
    vec2 fog = getFogFiltered(coord);
    float fog_transmittance = exp(-fog.g);
    color = color * fog_transmittance + cParams.fogColor.rgb * fog.r;
    // Alternative:
//    color += cParams.fogColor * fog.r;

    // Tonemapping
    // Note: the agx tonemap already includes srgb conversion (somehow)
    color = tonemapAgX(color);

    imageStore(out_color, coord, vec4(color, 1.0));
}