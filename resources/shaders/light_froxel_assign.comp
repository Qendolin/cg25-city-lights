#version 460 core

#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#include "common/math.glsl"
#include "fog_common.glsl"

#define MAX_FAR_Z 4096.0

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout (std430, set = 0, binding = 0) writeonly restrict buffer ClusterLightIndicesBuffer {
    uint uClusterLightIndices[];
};

layout (std430, set = 0, binding = 1) readonly buffer UberLightBuffer {
    UberLight uUberLightBuffer[];
};

layout (push_constant) uniform ShaderParamConstants {
    mat4 inverseViewMatrix;
    vec2 inverseProjectionScale;
    vec2 inverseProjectionOffset;
    vec3 cameraPosition;
    float zNear;
    vec3 cameraForward;
    float pad0;
} cParams;

float depthToViewZ(float d) {
    return cParams.zNear / d;
}

uint viewZToSlice(float z) {
    float z_clamped = max(z, cParams.zNear);
    float k = log(z_clamped / cParams.zNear) / log(FOG_MAX_DISTANCE / cParams.zNear);
    return uint(clamp(k * float(CLUSTER_DIM_Z), 0.0, float(CLUSTER_DIM_Z) - 1.0));
}

vec3 getUnitDepthViewVec(vec2 p) {
    vec2 ray_xy = fma(p, cParams.inverseProjectionScale, cParams.inverseProjectionOffset);
    return vec3(ray_xy.x, -ray_xy.y, -1.0);
}

void getSpotlightProjectedZBounds(float lightP_Z, float lightD_Z, float R, float cosTheta, out float minZ, out float maxZ) {
    minZ = lightP_Z;
    maxZ = lightP_Z;

    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));
    float ringCenterZ = lightP_Z + lightD_Z * R * cosTheta;
    float ringRadius = R * sinTheta;
    float orientationFactor = sqrt(max(0.0, 1.0 - lightD_Z * lightD_Z));
    float ringExtentZ = ringRadius * orientationFactor;

    minZ = min(minZ, ringCenterZ - ringExtentZ);
    maxZ = max(maxZ, ringCenterZ + ringExtentZ);

    if (lightD_Z > cosTheta) maxZ = max(maxZ, lightP_Z + R);
    if (lightD_Z < -cosTheta) minZ = min(minZ, lightP_Z - R);
}

bool testSphereVsTaperedCapsule(vec3 sphereCenter, float sphereRadius, vec3 A, vec3 B, float rA, float rB) {
    vec3 segDir = B - A;
    float segLenSq = dot(segDir, segDir);
    float t = 0.0;
    if (segLenSq > 1e-6) {
        t = clamp(dot(sphereCenter - A, segDir) / segLenSq, 0.0, 1.0);
    }
    vec3 closestPoint = A + t * segDir;
    float capRadius = mix(rA, rB, t);
    vec3 distVec = closestPoint - sphereCenter;
    float distSq = dot(distVec, distVec);
    float minDist = sphereRadius + capRadius;
    return distSq <= (minDist * minDist);
}

bool testSpotlightVsTaperedCapsule(vec3 lightPos, vec3 lightDir, float lightRange, float lightCosHalfAngle, vec3 A, vec3 B, float rA, float rB) {
    if (!testSphereVsTaperedCapsule(lightPos, lightRange, A, B, rA, rB)) {
        return false;
    }

    float sinAlpha = sqrt(1.0 - lightCosHalfAngle * lightCosHalfAngle);
    float tanAlpha = sinAlpha / lightCosHalfAngle;

    vec3 V = B - A;
    vec3 X0 = A - lightPos;

    float r0 = rA;
    float dr = rB - rA;

    float DV  = dot(lightDir, V);
    float DX0 = dot(lightDir, X0);
    float VV  = dot(V, V);
    float XV  = dot(X0, V);
    float XX  = dot(X0, X0);

    float a_dist = VV - DV * DV;
    float b_dist = 2.0 * (XV - DX0 * DV);
    float c_dist = XX - DX0 * DX0;

    float slope  = DV * tanAlpha + dr;
    float origin = DX0 * tanAlpha + r0;

    float a_cone = slope * slope;
    float b_cone = 2.0 * slope * origin;
    float c_cone = origin * origin;

    float A_quad = a_dist - a_cone;
    float B_quad = b_dist - b_cone;
    float C_quad = c_dist - c_cone;

    if (C_quad <= 0.0) {
        if (origin >= 0.0) return true;
    }

    if (A_quad + B_quad + C_quad <= 0.0) {
        if (slope + origin >= 0.0) return true;
    }

    if (A_quad > 1e-6) {
        float t = -B_quad / (2.0 * A_quad);
        if (t > 0.0 && t < 1.0) {
            float val = A_quad*t*t + B_quad*t + C_quad;
            if (val <= 0.0 && (slope * t + origin >= 0.0)) {
                return true;
            }
        }
    }

    return false;
}

shared uint sSliceLightCounts[CLUSTER_DIM_Z];
shared uint sSliceLightIndices[CLUSTER_DIM_Z][MAX_LIGHTS_PER_CLUSTER];

void main() {
    // 1. Initialize Shared Memory
    if (gl_LocalInvocationIndex < CLUSTER_DIM_Z) {
        sSliceLightCounts[gl_LocalInvocationIndex] = 0;
    }

    barrier();

    // Use Integer coordinates. C++ helper includes the +0.5 offset in cParams.inverseProjectionOffset.
    vec2 clusterCoord = vec2(gl_WorkGroupID.xy);

    // inverseProjectionScale is 2.0 * P_inv / GridDim.
    // 0.5 * scale gives half-diagonal size of one cluster.
    float radiusAtUnity = length(cParams.inverseProjectionScale * 0.707);

    vec3 viewVecAtUnity = getUnitDepthViewVec(clusterCoord);

    vec3 capN = viewVecAtUnity * cParams.zNear;
    vec3 capF = viewVecAtUnity * FOG_MAX_DISTANCE;
    float radN = radiusAtUnity * cParams.zNear;
    float radF = radiusAtUnity * FOG_MAX_DISTANCE;

    // Transform to World Space
    capN = (cParams.inverseViewMatrix * vec4(capN, 1.0)).xyz;
    capF = (cParams.inverseViewMatrix * vec4(capF, 1.0)).xyz;

    // 3. Parallel Light Loop
    // Each thread processes a subset of lights
    for (uint i = gl_LocalInvocationIndex; i < uUberLightBuffer.length(); i += gl_WorkGroupSize.x) {
        UberLight light = uUberLightBuffer[i];
        if(light.radiance == vec3(0.0))
            continue;

        bool intersectsBeam = false;
        vec3 lightDir = vec3(0.0);
        float cos_outer = 0.0;
        float range = light.range;

        // Phase 1: World Space Beam Intersection
        if (light.coneAngleScale == 0.0) {
            intersectsBeam = testSphereVsTaperedCapsule(light.position, range, capN, capF, radN, radF);
        } else {
            lightDir = octahedronDecode(light.direction);
            cos_outer = -light.coneAngleOffset / light.coneAngleScale;
            intersectsBeam = testSpotlightVsTaperedCapsule(light.position, lightDir, range, cos_outer, capN, capF, radN, radF);
        }

        if (!intersectsBeam) continue;

        // Phase 2: Projected Z-Interval Check
        float lMinZ, lMaxZ;
        float lightP_Z = dot(light.position - cParams.cameraPosition, cParams.cameraForward);

        if (light.coneAngleScale == 0.0) {
            lMinZ = lightP_Z - range;
            lMaxZ = lightP_Z + range;
        } else {
            float lightD_Z = dot(lightDir, cParams.cameraForward);
            getSpotlightProjectedZBounds(lightP_Z, lightD_Z, range, cos_outer, lMinZ, lMaxZ);
        }

        // Phase 3: Slice Assignment
        uint startSlice = viewZToSlice(lMinZ);
        uint endSlice   = viewZToSlice(lMaxZ);

        startSlice = max(startSlice, 0);
        endSlice   = min(endSlice, CLUSTER_DIM_Z - 1);

        for (uint s = startSlice; s <= endSlice; ++s) {
            // No Depth Culling (as requested)
            uint idx = atomicAdd(sSliceLightCounts[s], 1);
            if (idx < MAX_LIGHTS_PER_CLUSTER) {
                sSliceLightIndices[s][idx] = i;
            }
        }
    }

    barrier();

    // 4. Flush to Global Memory
    // Global Index = ( (TileY * Width + TileX) * DIM_Z + Slice ) * Stride
    uint tile_flat_index = gl_WorkGroupID.y * CLUSTER_DIM_X + gl_WorkGroupID.x;
    uint base_global_offset = (tile_flat_index * CLUSTER_DIM_Z) << CLUSTER_LIGHT_STRIDE_SHIFT;

    // We have 24 slices to write. Threads cooperate.
    // Flatten the loop: iterate over all slices
    for (uint s = 0; s < CLUSTER_DIM_Z; ++s) {
        uint count = min(sSliceLightCounts[s], MAX_LIGHTS_PER_CLUSTER);
        uint slice_offset = base_global_offset + (s << CLUSTER_LIGHT_STRIDE_SHIFT);

        // One thread writes the count
        if (gl_LocalInvocationIndex == 0) {
            uClusterLightIndices[slice_offset] = count;
        }

        // Parallel copy of indices
        // Using gl_WorkGroupSize.x (64) stride
        for (uint k = gl_LocalInvocationIndex; k < count; k += gl_WorkGroupSize.x) {
            uClusterLightIndices[slice_offset + 1 + k] = sSliceLightIndices[s][k];
        }
    }
}