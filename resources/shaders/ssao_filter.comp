#version 460

#include "common/math.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0) uniform sampler2D in_source;
layout (set = 0, binding = 1) uniform sampler2D in_depth;
layout (set = 0, binding = 2) uniform writeonly restrict image2D out_result;

layout (constant_id = 0) const bool BENT_NORMALS = true;

layout (push_constant) uniform ShaderParamPush {
    vec2 direction;
    float zNear;
    float sharpness;
    float exponent;
} cParams;

// 13-tap effective -> 4 bilinear taps
const float WEIGHTS[4] = float[]( 0.044787, 0.134685, 0.248200, 0.144657 );

const float OFFSETS[3] = float[]( -5.333107, -3.391331, -1.452815 );

float getLinearZ(vec2 uv) {
    float d = textureLod(in_depth, uv, 0).x;
    return cParams.zNear / d;
}

void main() {
    ivec2 size = textureSize(in_source, 0);
    ivec2 p = ivec2(gl_GlobalInvocationID.xy);

    if (p.x >= size.x || p.y >= size.y) return;

    vec2 texel_size = 1.0f / vec2(size);
    vec2 center_uv = (vec2(p) + 0.5f) * texel_size;
    float center_z = getLinearZ(center_uv);

    vec4 center_src = textureLod(in_source, center_uv, 0);
    float center_ao = center_src.x;

    float center_bn_mag;
    vec3 center_bn_dir, center_bn;
    if (BENT_NORMALS) {
        center_bn_mag = center_src.w;
        center_bn_dir = octahedronDecode(center_src.yz);
        center_bn = center_bn_dir * center_bn_mag;
    }

    // Calculate Slope
    // We only care about the slope along the current blur direction.
    // We check immediate neighbors to estimate how Z changes per pixel.
    vec2 offset_one = cParams.direction * texel_size;

    float z_plus_1 = getLinearZ(center_uv + offset_one);
    float z_minus_1 = getLinearZ(center_uv - offset_one);

    // Calculate Forward and Backward gradients
    float grad_fwd = z_plus_1 - center_z;
    float grad_bwd = center_z - z_minus_1;

    // Use the smallest gradient to avoid smoothing over creases (corners)
    // If we are on a flat slope, fwd and bwd are similar.
    // If we are on a corner, one will be huge. We pick the safe one.
    float gradient = (abs(grad_fwd) < abs(grad_bwd)) ? grad_fwd : grad_bwd;

    // Initialize Accumulators
    float total_weight = WEIGHTS[3];  // center
    float total_ao = center_ao * total_weight;
    vec3 total_bn = center_bn * total_weight;

    // Loop: only 2 iterations instead of 4
    for (int i = 0; i < 3; i++) {
        float offset = OFFSETS[i];
        vec2 uv_offset = cParams.direction * offset * texel_size;

        // Positive Side
        {
            vec2 uv = center_uv + uv_offset;
            float z = getLinearZ(uv);
            vec4 src = textureLod(in_source, uv, 0);

            float expected_z = center_z + gradient * offset;
            float error = abs(z - expected_z);

            // plane / depth weight
            float plane_w = max(0.0f, 1.0f - error * cParams.sharpness);

            // angular similarity: prefer neighbors pointing roughly the same way
            // float ang_w = max(dot(center_bn_dir, bn_dir), 0.0f);

            float w = WEIGHTS[i] * plane_w;

            float ao = src.x;
            total_ao += ao * w;

            if(BENT_NORMALS) {
                float bn_mag = src.w;
                vec3 bn_dir = octahedronDecode(src.yz);
                vec3 bn = bn_dir * bn_mag;
                total_bn += bn * w;
            }

            total_weight += w;
        }

        // Negative Side
        {
            vec2 uv = center_uv - uv_offset;
            vec4 src = textureLod(in_source, uv, 0);
            float z = getLinearZ(uv);

            float expected_z = center_z + gradient * offset;
            float error = abs(z - expected_z);

            // plane / depth weight
            float plane_w = max(0.0f, 1.0f - error * cParams.sharpness);

            // angular similarity: prefer neighbors pointing roughly the same way
            // float ang_w = max(dot(center_bn_dir, bn_dir), 0.0f);

            float w = WEIGHTS[i] * plane_w;

            float ao = src.x;
            total_ao += ao * w;

            if(BENT_NORMALS) {
                float bn_mag = src.w;
                vec3 bn_dir = octahedronDecode(src.yz);
                vec3 bn = bn_dir * bn_mag;
                total_bn += bn * w;
            }

            total_weight += w;
        }
    }

    float out_ao = total_ao / max(total_weight, 0.0001f);
    out_ao = pow(out_ao, cParams.exponent);

    vec4 result = vec4(out_ao);

    if(BENT_NORMALS) {
        vec3 out_bn = total_bn / max(total_weight, 0.0001f);
        float out_bn_mag = length(out_bn);
        vec3 out_bn_dir;
        if (out_bn_mag > 1e-5) {
            out_bn_dir =  out_bn / out_bn_mag;
        } else {
            out_bn_dir = center_bn_dir;
            out_bn_mag = center_bn_mag;
        }
        vec2 out_bn_encoded = octahedronEncode(out_bn_dir);

        result.yz = out_bn_encoded;
        result.w = out_bn_mag;
    }

    imageStore(out_result, p, result);
}