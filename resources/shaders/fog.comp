#version 460 core

#extension GL_KHR_shader_subgroup_shuffle : require

#include "common/math.glsl"
#include "fog_common.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#define SHADOW_CASCADE_COUNT 5

struct ShadowCascade {
    mat4 transform;
    vec2 boundsMin;
    vec2 boundsMax;
};

layout(set = 0, binding = 0) uniform sampler2DMS in_depth;
layout(set = 0, binding = 1) uniform restrict writeonly image2D out_result;
layout(set = 0, binding = 2) uniform sampler2DShadow uShadowMaps[SHADOW_CASCADE_COUNT];

layout (std140, set = 0, binding = 3) uniform ShadowCascadesUniforms {
    ShadowCascade[SHADOW_CASCADE_COUNT] uShadowCascades;
};

layout (std430, set = 0, binding = 4) readonly buffer UberLightBuffer {
    UberLight uUberLightBuffer[];
};

layout (std430, set = 0, binding = 5) readonly buffer ClusterLightIndicesBuffer {
    uint uClusterLightIndices[];
};

layout (push_constant) uniform ShaderParamConstants
{
    mat4 inverseViewMatrix;
    vec2 inverseProjectionScale;
    vec2 inverseProjectionOffset;
    vec3 sunUpVS;
    float zNear;
    vec3 sunRightVS;
    float density;
    vec3 sunRadiance;
    float targetStepContribution;
    vec3 ambientRadiance;
    float cameraHeight;
    vec3 worldUpVS;
    float heightFalloff;
    vec3 fogColor;
    uint samples;
    vec3 sunDirVS;
    float g;
    vec3 cameraPosition;
    uint frame;
} cParams;

vec3 unprojectRay(vec2 p) {
    vec2 ray_xy = fma(p, cParams.inverseProjectionScale, cParams.inverseProjectionOffset);
    return normalize(vec3(ray_xy.x, -ray_xy.y, -1.0f));
}

float depthToViewZ(float d) {
    return cParams.zNear / d;
}

uint viewZToSlice(float z) {
    float z_clamped = max(z, cParams.zNear);
    float k = log(z_clamped / cParams.zNear) / log(FOG_MAX_DISTANCE / cParams.zNear);
    return uint(clamp(k * float(CLUSTER_DIM_Z), 0.0, float(CLUSTER_DIM_Z) - 1.0));
}

float interleavedGradientNoise(vec2 screen_pos, uint frame_count) {
    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);
    float noise = fract(magic.z * fract(dot(screen_pos, magic.xy)));
    return fract(noise + float(frame_count % 64) * 0.61803398875);
}

vec2 r2Sequence(uint n) {
    const float g = 1.32471795724474602596;
    const float a1 = 1.0 / g;
    const float a2 = 1.0 / (g * g);
    return fract(vec2(a1, a2) * float(n));
}

const float MIN_STEP_SIZE = 0.05;
const float MAX_STEP_SIZE = 25.0;
const float EPSILON_DENSITY = 1e-5;

float henyeyGreenstein(float g, float cos_theta) {
    float g2 = g * g;
    float num = 1.0 - g2;
    float denom = 4.0 * PI * pow(max(0.001, 1.0 + g2 - 2.0 * g * cos_theta), 1.5);
    return num / max(denom, 0.0001);
}

float getDistanceAttenuation(float distance, float radius, float pointSize) {
    float s = distance / radius;
    if (s >= 1.0) return 0.0;

    float s2 = s * s;
    return saturate((1.0 - s2) / (distance * distance + pointSize));
}

float getSpotAttenuation(vec3 lightDir, vec3 L, float scale, float offset) {
    float cd = dot(lightDir, -L);
    float angularAttenuation = saturate(cd * scale + offset);
    return angularAttenuation * angularAttenuation;
}

float computeAdaptiveStep(float extinction, float current_transmittance) {
    if (extinction < EPSILON_DENSITY || current_transmittance < 0.001) {
        return MAX_STEP_SIZE;
    }

    float target_contribution = cParams.targetStepContribution;
    float ln_arg = max(1.0 - target_contribution / current_transmittance, 0.001);
    float step = -log(ln_arg) / extinction;

    return clamp(step, MIN_STEP_SIZE, MAX_STEP_SIZE);
}

void main() {
    if (any(greaterThanEqual(gl_GlobalInvocationID.xy, imageSize(out_result)))) {
        return;
    }
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    vec2 screen_uv = (vec2(coord) + 0.5) / vec2(imageSize(out_result));
    uvec2 cluster_xy = uvec2(screen_uv * vec2(CLUSTER_DIM_X, CLUSTER_DIM_Y));
    cluster_xy = min(cluster_xy, uvec2(CLUSTER_DIM_X - 1, CLUSTER_DIM_Y - 1)); // Safety clamp

    // Calculate flat index for this column of froxels
    uint tile_flat_index = cluster_xy.y * CLUSTER_DIM_X + cluster_xy.x;
    uint cluster_col_offset = (tile_flat_index * CLUSTER_DIM_Z) << CLUSTER_LIGHT_STRIDE_SHIFT;

    // min -> farthest depth
    float depth = min(
        min(texelFetch(in_depth, coord*2 + ivec2(0, 0), 0).r, texelFetch(in_depth, coord*2 + ivec2(1, 0), 0).r),
        min(texelFetch(in_depth, coord*2 + ivec2(0, 1), 0).r, texelFetch(in_depth, coord*2 + ivec2(1, 1), 0).r)
    );
    float scene_view_z = depthToViewZ(depth);

    vec3 ray_vs = unprojectRay(vec2(coord) + 0.5);
    vec3 ray_ws = mat3(cParams.inverseViewMatrix) * ray_vs;

    float initial_jitter = interleavedGradientNoise(vec2(coord), cParams.frame);

    float t = 0.0;
    vec3 radiance = vec3(0.0);
    float transmittance = 1.0;

    int cascade_index = 0;

    for (uint i = 0; i < cParams.samples; ++i) {
        vec2 r2 = r2Sequence(i + cParams.frame * cParams.samples);
        float sample_jitter = fract(initial_jitter + r2.x);

        vec3 p_vs = ray_vs * t;
        vec3 p_ws = cParams.cameraPosition + ray_ws * t;

        float height = cParams.cameraHeight + dot(p_vs, cParams.worldUpVS);
        float height_factor = exp(-cParams.heightFalloff * max(height, 0.0));
        float extinction = cParams.density * height_factor;

        float step_size = computeAdaptiveStep(extinction, transmittance);
        step_size = min(step_size, scene_view_z - t);

        float jittered_step = step_size * (0.5 + 0.5 * sample_jitter);
        t += jittered_step;

        if (t >= scene_view_z || transmittance < 0.01) {
            break;
        }

        p_vs = ray_vs * t;
        p_ws = cParams.cameraPosition + ray_ws * t;
        height = cParams.cameraHeight + dot(p_vs, cParams.worldUpVS);

        if (height < -1.0f) break;

        height_factor = exp(-cParams.heightFalloff * max(height, 0.0));
        extinction = cParams.density * height_factor;

        // Shadow Map (Sun)
        float lx = dot(p_vs, cParams.sunRightVS.xyz);
        float ly = dot(p_vs, cParams.sunUpVS.xyz);

        for (int j = cascade_index; j < SHADOW_CASCADE_COUNT; ++j) {
            if (lx >= uShadowCascades[j].boundsMin.x && ly >= uShadowCascades[j].boundsMin.y
            && lx <= uShadowCascades[j].boundsMax.x && ly <= uShadowCascades[j].boundsMax.y) {
                cascade_index = j;
                break;
            }
        }

        vec4 p_shadow_ndc = uShadowCascades[cascade_index].transform * vec4(p_vs, 1.0);
        vec3 shadow_uvz = vec3(p_shadow_ndc.xy * 0.5 + 0.5, p_shadow_ndc.z);
        float shadow = texture(uShadowMaps[cascade_index], shadow_uvz);

        float cos_theta_sun = dot(ray_vs, cParams.sunDirVS);
        float phase_sun = henyeyGreenstein(cParams.g, cos_theta_sun);

        vec3 in_radiance = cParams.sunRadiance * shadow * phase_sun + cParams.ambientRadiance;

        // Local Lights
        float view_dist_z = abs(p_vs.z);
        if (view_dist_z < FOG_MAX_DISTANCE || true) {
            uint z_slice = viewZToSlice(view_dist_z);
            uint slice_offset = cluster_col_offset + (z_slice << CLUSTER_LIGHT_STRIDE_SHIFT);
            uint light_count = uClusterLightIndices[slice_offset];

            for (uint k = 0; k < light_count; ++k) {
                uint light_index = uClusterLightIndices[slice_offset + 1 + k];
                UberLight light = uUberLightBuffer[light_index];

                vec3 L = light.position - p_ws;
                float dist = length(L);

                if (dist < light.range) {
                    L /= dist;
                    float att = getDistanceAttenuation(dist, light.range, light.pointSize);

                    if (light.coneAngleScale != 0.0) {
                        vec3 spotDir = octahedronDecode(light.direction);
                        att *= getSpotAttenuation(spotDir, L, light.coneAngleScale, light.coneAngleOffset);
                    }

                    float phase_local = henyeyGreenstein(cParams.g, dot(ray_ws, L));
                    in_radiance += light.radiance * att * phase_local;
                }
            }
        }

        float step_extinction = extinction * jittered_step;
        float step_transmittance = exp(-step_extinction);
        transmittance *= step_transmittance;

        float one_minus_t = 1.0 - step_transmittance;
        radiance += transmittance * in_radiance * one_minus_t;
    }

    float optical_depth = -log(max(transmittance, 1e-6));
    imageStore(out_result, coord, vec4(radiance * cParams.fogColor, optical_depth));
}