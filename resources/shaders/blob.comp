#version 460

#include "blob_lookup.glsl"

layout(local_size_x = 8, local_size_y = 4, local_size_z = 4) in;

layout(push_constant) uniform PushConsts {
    int resolution;
    float time;
} pc;

struct Vertex {
    vec4 position;   // .w = 1.0
    vec4 normal;     // .xyz = normal, .w = 0.0
    vec4 tangent;    // .xyz = tangent, .w = handedness (+1 or -1)
};

layout(set = 0, binding = 0, std430) buffer Vertices {
    Vertex vertices[];
};

layout(set = 0, binding = 1, std430) buffer DrawArgs {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} drawArgs;

// Omit lookup tables: edgeVertexIndices, edgeTable, triangleTable

const float INTERVAL_START = -1.0;
const float INTERVAL_END   =  1.0;
const float ISO_VALUE      =  0.0;
const float EPS            =  1e-4;  // Slightly larger to avoid numerical issues
const float TWO_PI         =  6.28318530718;
const float PI             =  3.14159265359;

float stepSize;

struct IntersectionPoint {
    vec3 position;
    vec3 normal;
};

vec3 cellVertices[8];
float cellSamples[8];
int cubeLookupIndex;
IntersectionPoint intersectionPoints[12];

shared uint groupVertexCount;
shared uint groupGlobalBaseIndex;

float sphereSdf(vec3 p, vec3 c, float r) {
    return length(p - c) - r;
}

float smoothMin(float a, float b, float k) {
    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
    return mix(b, a, h) - k * h * (1.0 - h);
}

float sdf(vec3 p) {
    float t = mod(pc.time, TWO_PI);  // Loop time smoothly over 0 to 2Ï€

    vec3 core = vec3(0.0, 0.3, 0.0);
    float coreR = 0.2 + t / 24.0;
    float s0 = sphereSdf(p, core, coreR);

    float t2 = pc.time * 2.0;
    float t4 = pc.time * 4.0;

    vec3 c1 = vec3(0.25 * cos(t2), 0.3, 0.25 * sin(t2));
    float s1 = sphereSdf(p, c1, 0.2);

    vec3 c2 = vec3(0.25 * cos(t2 + PI), 0.25 * sin(t2) + 0.3 - 0.05, 0.0);
    float s2 = sphereSdf(p, c2, 0.2);

    vec3 c3 = vec3(0.0, 0.30 * cos(-t4) + 0.3 - 0.05, 0.30 * sin(-t4));
    float s3 = sphereSdf(p, c3, 0.2);

    vec3 drip = vec3(0.0, 0.3 - t, 0.0);
    float s4 = sphereSdf(p, drip, 0.1);

    float val = smoothMin(s0, s1, 0.4);
    val = smoothMin(val, s2, 0.4);
    val = smoothMin(val, s3, 0.4);
    val = smoothMin(val, s4, 0.4);

    return smoothMin(val, p.y + 1.05, 0.4);  // Ground plane
}

void setCellVertices(int i, int j, int k) {
    float s = stepSize;
    float x0 = INTERVAL_START + float(i) * s;
    float y0 = INTERVAL_START + float(j) * s;
    float z0 = INTERVAL_START + float(k) * s;

    cellVertices[0] = vec3(x0, y0, z0);
    cellVertices[1] = vec3(x0 + s, y0, z0);
    cellVertices[2] = vec3(x0, y0 + s, z0);
    cellVertices[3] = vec3(x0 + s, y0 + s, z0);
    cellVertices[4] = vec3(x0, y0, z0 + s);
    cellVertices[5] = vec3(x0 + s, y0, z0 + s);
    cellVertices[6] = vec3(x0, y0 + s, z0 + s);
    cellVertices[7] = vec3(x0 + s, y0 + s, z0 + s);
}

void setCellSamples() {
    for (int v = 0; v < 8; ++v) {
        cellSamples[v] = sdf(cellVertices[v]);
    }
}

void setCubeLookupIndex() {
    cubeLookupIndex = 0;
    for (int v = 0; v < 8; ++v) {
        if (cellSamples[v] < ISO_VALUE) {
            cubeLookupIndex |= (1 << v);
        }
    }
}

vec3 interpolate(vec3 a, vec3 b, float va, float vb) {
    float t = (ISO_VALUE - va) / (vb - va + 1e-8);  // Avoid div by zero
    return mix(a, b, t);
}

vec3 calculateNormal(vec3 p) {
    float d = sdf(p);
    vec3 grad = vec3(
    sdf(p + vec3(EPS, 0.0, 0.0)) - d,
    sdf(p + vec3(0.0, EPS, 0.0)) - d,
    sdf(p + vec3(0.0, 0.0, EPS)) - d
    );
    return normalize(grad);
}

vec4 calculateTangent(vec3 normal) {
    vec3 helper = abs(normal.y) > 0.99 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
    vec3 tangent = normalize(cross(normal, helper));
    return vec4(tangent, 1.0);
}

void calculateBoxUVsAndTangent(vec3 p, vec3 n, out vec2 uv, out vec4 tangent) {
    vec3 absN = abs(n);

    // Determine the dominant axis to project from (Box Mapping)
    if (absN.x > absN.y && absN.x > absN.z) {
        // X-Axis projection (Left/Right)
        // Tangent is along Z
        float signX = sign(n.x);
        uv = vec2(-signX * p.z, p.y) * 0.5 + 0.5; // Scale UVs as needed
        tangent = vec4(0.0, 0.0, -signX, 1.0);    // Tangent points along Z
    }
    else if (absN.y > absN.x && absN.y > absN.z) {
        // Y-Axis projection (Top/Bottom) - The "Pole" area
        // Tangent is along X
        float signY = sign(n.y);
        uv = vec2(p.x, signY * p.z) * 0.5 + 0.5;
        tangent = vec4(1.0, 0.0, 0.0, 1.0);       // Tangent points along X
    }
    else {
        // Z-Axis projection (Front/Back)
        // Tangent is along X
        float signZ = sign(n.z);
        uv = vec2(signZ * p.x, p.y) * 0.5 + 0.5;
        tangent = vec4(signZ, 0.0, 0.0, 1.0);     // Tangent points along X
    }

    // Orthogonalize tangent against the smooth normal
    // to ensure the normal map sits flat on the curved surface
    vec3 tXYZ = tangent.xyz;
    tXYZ = normalize(tXYZ - n * dot(n, tXYZ));
    tangent.xyz = tXYZ;
}

void setIntersectionPoints() {
    int edgeKey = edgeTable[cubeLookupIndex];

    int idx = 0;
    int bit = 1;
    while (edgeKey != 0 && idx < 12) {
        if ((edgeKey & bit) != 0) {
            int v0 = edgeVertexIndices[idx][0];
            int v1 = edgeVertexIndices[idx][1];

            vec3 pos = interpolate(cellVertices[v0], cellVertices[v1],
            cellSamples[v0], cellSamples[v1]);

            intersectionPoints[idx].position = pos;
            intersectionPoints[idx].normal = calculateNormal(pos);
        }
        idx++;
        bit <<= 1;
    }
}

vec2 uvFromPos(vec3 pos) {
    vec3 n = normalize(pos);
    float u = atan(n.z, n.x) / TWO_PI + 0.5;
    float v = n.y * 0.5 + 0.5;
    return vec2(u, v);
}

void main() {
    uvec3 gid = gl_GlobalInvocationID;
    int i = int(gid.x);
    int j = int(gid.y);
    int k = int(gid.z);

    // Note: No early returns because barrier is used

    stepSize = (INTERVAL_END - INTERVAL_START) / float(pc.resolution);

    setCellVertices(i, j, k);
    setCellSamples();
    setCubeLookupIndex();

    setIntersectionPoints();

    // Count triangles for this cell
    uint numTris = 0;
    for (int t = 0; t < 12 && triangleTable[cubeLookupIndex][t] != -1; t += 3) {
        ++numTris;
    }
    uint numVerts = numTris * 3;

    // Shared memory atomic for group
    if (gl_LocalInvocationIndex == 0) {
        groupVertexCount = 0;
    }
    barrier();

    uint localOffset = atomicAdd(groupVertexCount, numVerts);

    barrier();

    if (gl_LocalInvocationIndex == 0) {
        groupGlobalBaseIndex = atomicAdd(drawArgs.vertexCount, groupVertexCount);
    }
    barrier();

    uint baseIndex = groupGlobalBaseIndex + localOffset;
    uint vertIdx = baseIndex;

    // Emit triangles
    for (int t = 0; t < 12 && triangleTable[cubeLookupIndex][t] != -1; t += 3) {
        int e0 = triangleTable[cubeLookupIndex][t + 0];
        int e1 = triangleTable[cubeLookupIndex][t + 1];
        int e2 = triangleTable[cubeLookupIndex][t + 2];

        vec3 pos0 = intersectionPoints[e0].position;
        vec3 pos1 = intersectionPoints[e1].position;
        vec3 pos2 = intersectionPoints[e2].position;

        vec3 n0 = intersectionPoints[e0].normal;
        vec3 n1 = intersectionPoints[e1].normal;
        vec3 n2 = intersectionPoints[e2].normal;

        vec4 t0 = calculateTangent(n0);
        vec4 t1 = calculateTangent(n1);
        vec4 t2 = calculateTangent(n2);

        vertices[vertIdx++] = Vertex(vec4(pos0, 1.0), vec4(n0, 0.0), t0);
        vertices[vertIdx++] = Vertex(vec4(pos1, 1.0), vec4(n1, 0.0), t1);
        vertices[vertIdx++] = Vertex(vec4(pos2, 1.0), vec4(n2, 0.0), t2);
    }
}