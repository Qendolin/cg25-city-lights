#version 460

#extension GL_EXT_samplerless_texture_functions: require

#include "common/math.glsl"

// ------------------------------------------------------------------
// CONFIGURATION
// ------------------------------------------------------------------

// Integration Modes
#define MODE_GTAO_GROUND_TRUTH 0    // Physically correct, View-Independent
#define MODE_GTAO_APPROX       1    // Faster approximation of GT
#define MODE_HBAO_SINE         2    // Irradiance (Energy), View-Independent
#define MODE_HBAO_COSINE       3    // Solid Angle (Area), View-Independent
#define MODE_GTAO_RAW          4    // Physically correct, View-Dependent (Darkens at angles)

// Set active mode
#define INTEGRATION_MODE MODE_GTAO_GROUND_TRUTH

// Specialization Constants (Pipeline overridable, default 2)
layout (constant_id = 0) const int SLICE_COUNT = 2;
layout (constant_id = 1) const int SAMPLES_PER_SLICE_SIDE = 2;
layout (constant_id = 2) const bool BENT_NORMALS = true;

// ------------------------------------------------------------------
// CONSTANTS & UNIFORMS
// ------------------------------------------------------------------

layout (local_size_x = 8, local_size_y = 8) in;

layout (set = 0, binding = 0) uniform ShaderParamConstants {
    mat4 projection;
    vec2 inverseProjectionScale;
    vec2 inverseProjectionOffset;
    float zNear;
    float radius;
    float bias;
} cParams;

layout (set = 0, binding = 1) uniform sampler2D in_depth;
layout (set = 0, binding = 2) uniform writeonly restrict image2D out_ao;
layout (set = 0, binding = 3) uniform texture2D tex_blue_noise;

// ------------------------------------------------------------------
// HELPER FUNCTIONS
// ------------------------------------------------------------------

float depthToViewZ(float d) {
    return cParams.zNear / d;
}

float fast_acos(float x) {
    float res = -0.156583 * abs(x) + HALF_PI;
    res *= sqrt(1.0 - abs(x));
    return x >= 0 ? res : PI - res;
}

vec3 getPositionVS(vec2 p, float dist) {
    vec2 ray_xy = fma(p, cParams.inverseProjectionScale, cParams.inverseProjectionOffset);
    return vec3(ray_xy.x * dist, -ray_xy.y * dist, -dist);
}

float fetchDepth(ivec2 p, ivec2 dim) {
    p = clamp(p, ivec2(0), dim - 1);
    return texelFetch(in_depth, p, 0).x;
}

// Reconstructs surface normal from depth buffer
vec3 reconstructNormal(ivec2 p, float z_c, ivec2 depth_dim, int scale) {
    vec2 p_center = vec2(p) + 0.5;
    vec2 ray_c = fma(p_center, cParams.inverseProjectionScale, cParams.inverseProjectionOffset);
    vec2 s = cParams.inverseProjectionScale;

    ivec2 p_depth = p * scale;
    float d_r = fetchDepth(p_depth + ivec2(scale, 0), depth_dim);
    float d_l = fetchDepth(p_depth + ivec2(-scale, 0), depth_dim);
    float d_d = fetchDepth(p_depth + ivec2(0, scale), depth_dim);
    float d_u = fetchDepth(p_depth + ivec2(0, -scale), depth_dim);

    float z_r = depthToViewZ(d_r);
    float z_l = depthToViewZ(d_l);
    float z_d = depthToViewZ(d_d);
    float z_u = depthToViewZ(d_u);

    // ray.y is Vulkan NDC (Down), View Y is Up. Negate Y.
    #define MAKE_POS(rx, ry, z) vec3((rx) * (z), - (ry) * (z), - (z))

    vec3 p_c = MAKE_POS(ray_c.x, ray_c.y, z_c);
    vec3 p_r = MAKE_POS(ray_c.x + s.x, ray_c.y, z_r);
    vec3 p_l = MAKE_POS(ray_c.x - s.x, ray_c.y, z_l);
    vec3 p_d = MAKE_POS(ray_c.x, ray_c.y + s.y, z_d);
    vec3 p_u = MAKE_POS(ray_c.x, ray_c.y - s.y, z_u);

    vec3 t_x = abs(z_r - z_c) < abs(z_l - z_c) ? p_r - p_c : p_c - p_l;
    vec3 t_y = abs(z_d - z_c) < abs(z_u - z_c) ? p_d - p_c : p_c - p_u;

    return normalize(cross(t_y, t_x));
}

// Calculates visibility for a single slice based on the active mode
// Returns vec2(ActualVisibility, MaxPossibleVisibility)
vec2 calculateSliceVisibility(float n, float h1, float h2) {
    // Calculate Theoretical Max Visibility (for normalization)
    float h1_max = min(n + HALF_PI, HALF_PI);
    float h2_max = max(n - HALF_PI, -HALF_PI);

    #if INTEGRATION_MODE == MODE_GTAO_GROUND_TRUTH || INTEGRATION_MODE == MODE_GTAO_RAW
    // Exact GTAO Integral: 0.25 * (cos(n) + 2h*sin(n) - cos(2h-n))
    float i1 = (cos(n) + 2.0 * h1 * sin(n) - cos(2.0 * h1 - n));
    float i2 = (cos(n) + 2.0 * h2 * sin(n) - cos(2.0 * h2 - n));

    float i1_max = (cos(n) + 2.0 * h1_max * sin(n) - cos(2.0 * h1_max - n));
    float i2_max = (cos(n) + 2.0 * h2_max * sin(n) - cos(2.0 * h2_max - n));

    return vec2(i1 + i2, i1_max + i2_max);

    #elif INTEGRATION_MODE == MODE_GTAO_APPROX
    float i1 = (cos(n) + 2.0 * h1 * sin(n) - cos(2.0 * h1 - n));
    float i2 = (cos(n) + 2.0 * h2 * sin(n) - cos(2.0 * h2 - n));

    // Approximation: 2 * (n*sin(n) + cos(n))
    float possible = 2.0 * (n * sin(n) + cos(n));
    return vec2(i1 + i2, possible);

    #elif INTEGRATION_MODE == MODE_HBAO_SINE
    // Integral of cos(x) -> sin(x)
    float gamma1 = h1 - n;
    float gamma2 = n - h2;

    float val1 = sin(min(gamma1, HALF_PI));
    float val2 = sin(min(gamma2, HALF_PI));

    return vec2(val1 + val2, 2.0);

    #elif INTEGRATION_MODE == MODE_HBAO_COSINE
    // Integral of 1 -> 1 - cos(x)
    float gamma1 = h1 - n;
    float gamma2 = n - h2;

    float val1 = 1.0 - cos(min(gamma1, HALF_PI));
    float val2 = 1.0 - cos(min(gamma2, HALF_PI));

    return vec2(val1 + val2, 2.0);
    #endif
    return vec2(0.0);
}

// ------------------------------------------------------------------
// MAIN
// ------------------------------------------------------------------

void main() {
    ivec2 out_size = imageSize(out_ao).xy;
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);

    if (pix.x >= out_size.x || pix.y >= out_size.y) return;

    ivec2 depth_size = textureSize(in_depth, 0).xy;
    int img_scale = depth_size.x / out_size.x;

    // Reconstruction
    float d_c = fetchDepth(pix * img_scale, depth_size);
    float z_c = depthToViewZ(d_c);

    vec3 P = getPositionVS(vec2(pix) + 0.5, z_c);
    vec3 N = reconstructNormal(pix, z_c, depth_size, img_scale);
    vec3 V = normalize(-P);

    // Noise & Sampling Setup
    ivec2 noise_dim = textureSize(tex_blue_noise, 0);
    vec2 noise_vec = texelFetch(tex_blue_noise, pix % noise_dim, 0).xy;

    float proj_scale = cParams.projection[1][1] * float(out_size.y) * 0.5;
    float pixel_radius = (cParams.radius * proj_scale) / -P.z;

    if (pixel_radius < 1.0) {
        imageStore(out_ao, pix, vec4(1.0));
        return;
    }

    float falloff_range = 0.615 * cParams.radius;
    float falloff_mul = -1.0 / falloff_range;
    float falloff_add = (cParams.radius * (1.0 - 0.615)) / falloff_range + 1.0;
    float min_s = 1.5 / pixel_radius;

    float total_visibility = 0.0;
    float total_possible_vis = 0.0;
    vec3 total_bent_normal = vec3(0.0);

    // Sample Loop
    for (float slice = 0.0; slice < float(SLICE_COUNT); slice++) {
        float phi = (PI / float(SLICE_COUNT)) * (slice + noise_vec.x);
        vec2 omega = vec2(cos(phi), sin(phi));

        // Setup Slice Plane
        vec3 dir = vec3(omega, 0.0);
        vec3 ortho_dir = dir - (dot(dir, V) * V);
        vec3 axis = normalize(cross(dir, V));
        vec3 proj_n = N - axis * dot(N, axis);
        float proj_n_len = length(proj_n);

        float sign_n = sign(dot(ortho_dir, proj_n));
        float cos_n = saturate(dot(proj_n, V) / proj_n_len);
        float n = sign_n * fast_acos(cos_n);

        float max_cos_h1 = cos(n + HALF_PI);
        float max_cos_h2 = cos(n - HALF_PI);

        vec2 uv_dir = vec2(omega.x, -omega.y);
        vec2 sample_step = uv_dir * pixel_radius;

        for (float samp = 0.0; samp < float(SAMPLES_PER_SLICE_SIDE); samp++) {
            float noise_step = fract(noise_vec.y + slice + samp * 0.618);
            float s = (samp + noise_step) / float(SAMPLES_PER_SLICE_SIDE);
            s *= s; // Quadratic distribution
            s = max(min_s, s);

            vec2 offset = s * sample_step;
            ivec2 pix_offset = ivec2(round(offset)) * img_scale;

            // Side 1
            float d1 = fetchDepth(pix * img_scale + pix_offset, depth_size);
            vec3 P1 = getPositionVS(vec2(pix) + 0.5 + offset, depthToViewZ(d1));
            vec3 diff1 = P1 - P;
            float dist1 = length(diff1);
            float weight1 = saturate(dist1 * falloff_mul + falloff_add);
            float cos_h1 = dot(diff1 / dist1, V);
            cos_h1 -= cParams.bias;
            max_cos_h1 = max(max_cos_h1, mix(cos(n + HALF_PI), cos_h1, weight1));

            // Side 2
            float d2 = fetchDepth(pix * img_scale - pix_offset, depth_size);
            vec3 P2 = getPositionVS(vec2(pix) + 0.5 - offset, depthToViewZ(d2));
            vec3 diff2 = P2 - P;
            float dist2 = length(diff2);
            float weight2 = saturate(dist2 * falloff_mul + falloff_add);
            float cos_h2 = dot(diff2 / dist2, V);
            cos_h2 -= cParams.bias;
            max_cos_h2 = max(max_cos_h2, mix(cos(n - HALF_PI), cos_h2, weight2));
        }

        float h1 = fast_acos(max_cos_h1);
        float h2 = -fast_acos(max_cos_h2);

        // Clamp horizons to the tangent hemisphere
        h1 = n + max(h1 - n, -HALF_PI);
        h2 = n + min(h2 - n, HALF_PI);

        vec2 slice_res = calculateSliceVisibility(n, h1, h2);

        float visiblity = proj_n_len * slice_res.x;
        total_visibility += visiblity;
        total_possible_vis += proj_n_len * slice_res.y;

        // Bent Normals

        if(BENT_NORMALS) {
            float bent_angle = (h1 + h2) * 0.5;
            vec3 slice_tangent = normalize(ortho_dir);
            vec3 slice_bent = V * cos(bent_angle) + slice_tangent * sin(bent_angle);
            total_bent_normal += slice_bent * visiblity;
        }
    }

    // Normalization
    #if INTEGRATION_MODE == MODE_GTAO_RAW
    // Raw GTAO is not normalized by geometry, just averaged
    // This preserves the cosine-weighted light falloff (view dependency)
    total_visibility /= float(SLICE_COUNT);
    #else

    // The "normalization" factor fixes the view direction dependent darkening issue when following the original paper and common open implementations.
    // https://discord.com/channels/318590007881236480/699669145737756682/1402530766264733768
    // https://discord.com/channels/318590007881236480/1398853492826968136

    // All other modes normalize Actual / Possible to get 0..1 factor
    total_visibility /= max(total_possible_vis, 0.0001);
    #endif

    vec4 result = vec4(total_visibility);

    if (BENT_NORMALS) {
        float bent_normal_mag = length(total_bent_normal);
        vec3 bent_normal_dir;
        if (bent_normal_mag > 1e-5) {
            bent_normal_dir = total_bent_normal / bent_normal_mag;
        } else {
            bent_normal_dir = N;
            bent_normal_mag = 1.0;
        }
        vec2 bent_normal_encoded = octahedronEncode(bent_normal_dir);
        bent_normal_mag /= (float(SLICE_COUNT) * 2.0);// compress to 0-1 range (untested)

        result.yz = bent_normal_encoded;
        result.w = bent_normal_mag;
    }

    imageStore(out_ao, pix, result);
}